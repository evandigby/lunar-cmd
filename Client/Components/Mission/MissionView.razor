@attribute [Authorize]

@inject StateContainer state
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IUserClient userClient
@inject ILogEntryClient logEntryClient
@inject IHubConnectionFactory hubConnectionFactory
@inject ICommandClient commandClient
@inject Mission CurrentMission

@implements IAsyncDisposable

<div style="width:100%;height:100%;display: flex;flex-direction: column;">
    <div style="overflow: auto;flex-grow:1">
        <FluentTabs>
            @foreach (var log in CurrentMission.Logs)
            {
                <FluentTab>@log.Name</FluentTab>
                <FluentTabPanel><LogView CurrentLog=@log /></FluentTabPanel>
            }
        </FluentTabs>
    </div>
    <div style="width: 100%;overflow: hidden;flex-shrink: 0;padding:2px;">
        <EditForm style="width: 100%" Model=@CurrentMission OnValidSubmit=@Enter>
            <div style="display: flex; flex-direction: row;">
                <InputText style="flex-grow:1;margin:2px" @bind-Value=@CurrentMission.CurrentEntryText />
                <FluentButton style="flex-shrink: 0;margin:2px" type="submit">Send</FluentButton>
            </div>
        </EditForm>
    </div>
</div>

@code {
    [Parameter, EditorRequired]
    public Guid MissionID { get; set; } = Guid.Empty;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var src = new CancellationTokenSource();

            state.UpdateUser(await userClient.Me(src.Token));

            await LoadLogEntries();

            StateHasChanged();

            hubConnection = await hubConnectionFactory.ConnectHub<LogEntry>(
                new HubCommand<LogEntry>[]
                    {
                        new HubCommand<LogEntry>
                        {
                            CommandName = SignalRCommands.NewLogEntry,
                            OnReceive = (logEntry) =>
                            {
                                CurrentMission.AddLogEntry(logEntry);
                                StateHasChanged();
                            }
                        },
                        new HubCommand<LogEntry>
                        {
                            CommandName = SignalRCommands.UpdateLogEntry,
                            OnReceive = (logEntry) =>
                            {
                                CurrentMission.UpdateLogEntry(logEntry);
                                StateHasChanged();
                            }
                        }
                    });
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task LoadLogEntries()
    {
        var src = new CancellationTokenSource();

        try
        {
            var entries = await logEntryClient.GetLogEntriesByMissionId(MissionID, src.Token);

            CurrentMission.AddLogEntries(entries.OrderByDescending(e => e.LoggedAt));

            StateHasChanged();
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
    }

    private HubConnection? hubConnection;

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }

    private async Task Enter(EditContext editContext)
    {
        var cmd = new AppendLogEntryCommand
            {
                Payload = new PlaintextPayloadValue
                {
                    Value = CurrentMission.CurrentEntryText
                }
            };

        var src = new CancellationTokenSource();

        try
        {
            await commandClient.SendCommand(cmd, src.Token);
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }

        CurrentMission.CurrentEntryText = "";

        StateHasChanged();
    }
}
